       NAM LISP-STACK
       OPT PAG
       PAG
OBEGAD EQU $06A0
STKMIN EQU 50
MINFRE EQU 20
MRKBIT EQU 2
*
CAR    EQU 0
CDR    EQU 2
EOI    EQU 4
*
       LIB LISPLB
* GLOBAL VECTORS
       ORG $0100
EVAL   RMB 3
READ   RMB 3
PRINT  RMB 3
       RMB 3
       JMP GETCEL
       JMP FRECEL
       JMP PUSHX
       JMP POPX
       JMP TOPX
EVLATM RMB 3
SETATM RMB 3
LOOKUP RMB 3
GNXTL  RMB 3
GFNXTL RMB 3
LSTINI RMB 3
LSTADD RMB 3
LSTAD2 RMB 3
LSTEND RMB 3
LSTEN0 EQU POPX
ERREX  RMB 3
ATMINI RMB 3
ISDTPR RMB 3
ISATOM RMB 3
GETC   RMB 3
NUMINV RMB 3
NUMFRM RMB 3
FRMNUM RMB 3
PUTSYM RMB 3
PUTC   RMB 3
ERRBRK RMB 3
GETSYM RMB 3
       JMP STKFRG
       JMP GCOL
       JMP PROPSH
GETCAR RMB 3
       JMP ISVAR
PRINR  RMB 3
       JMP PROPOP
* JSR STKFRG WILL MAKE ROOM FOR MORE STACK, POSSIBLY
* FRAGMENTING THE STACK
*
* (XREG+4) CONTAINS OLD SP OF FORMER FRAGMENT
* (XREG+2) CONTAINS ADDR OF "UNRAVL" SUBROUTINE
* (XREG+0) CONTAINS RETURN ADDRESS FOR THIS SUBROUTINE
       ORG OBEGAD
STKFRG STS XTMP2                * CHECK LOW BYTE OF SP FOR MIN. STACKLIM
       LDAA XTMP2+1
CMPA   #STKMIN
       BLS STKF2
       RTS                      * ENOUGH ROOM, JUST RETURN
*
STKF2  STX XTMP2                * SAVE X-REG FOR RESTORE LATER
       LDAA ENDPTR
LDAB   ENDPTR+1                 * ADJUST ENDPTR TO 256-BYTE BOUNDARY
       BEQ STKF4
       BSR BLKFRE               * FREE UP BLCOK DOWN TO 256-BYTE BOUNDARY
       STX ENDPTR               * UPDATE ENDPTR
STKF4  DECA                     * ALLOCATE NEW 256-BYTE STACK FRAGMENT
CMPA   SPCPTR                   * BUMPING INTO NAME SPACE?
       BLS STKFUL
       STAA ENDPTR              * NOPE, UPDATE ENDPTR
       STAA XTMP
       LDAA #250
       STAA XTMP+1              * SET UP NEW STACK POINTER
       LDX XTMP                 * INITIALIZE NEW STACK FRAGMENT
       PULA                     * RETURN ADDR
       STAA 0,X
       PULA
       STAA 1,X
       STS 4,X                  * OLD SP
       LDAA UNRAVA              * ADDR OF UNRAVL ROUTINE
       STAA 2,X
       LDAA UNRAVA+1
       STAA 3,X
       TXS                      * SET NEW SP
       LDX XTMP2                * RESTORE X-REG
       RTS                      * AND RETURN
*
STKFUL LDX #STKEMG              * 'NO MORE ROOM FOR STACK FRAGMENT'
       JMP ERREX                * BYEBYE!
*
UNRAVA FDB UNRAVL               * ADDR OF UNRAVL ROUTINE
* UNRAVEL STACK FRAGMENT
* IF END OF FRAGMENT STILL EQUALS ENDPTR, SIMPLY RESET ENDPTR,
* OTHERWISE ADD SPACE TO FREE LIST
UNRAVL STX XTMP2                * SAVE X-REG
       TSX
       LDS 0,X                  * RESTORE OLD SP
       STX XTMP
       LDAA XTMP                * END OF FRAG = ENDPTR?
CMPA   ENDPTR
       BNE UNRFRE
       INCA                     * YEP, JUST UPDATE ENDPTR
       STAA ENDPTR              * (BY ADDING 256)
UNRVRT LDX XTMP2                * RESTORE X-REG
       RTS                      * AND RETURN
* FREE ALL CELLS WITHIN FRAGMENT
UNRFRE CLRB
       BSR BLKFRE
       BRA UNRVRT
* FREE BLOCK, A&B-REG SPECIFY TOP OF BLOCK
* AT RETURN, X-REG, A&B-REG, AND XTMP-A-REG POINT TO BOTTOM OF BLOCK
* XTMP+1 IS UNSPECIFIED ON ENTRY AND RETURN
BLKFRE STAA XTMP
SUBB   #4                       * FREE CELLS UTIL DOWN TO 256-BYTE BOUNDARY
STAB   XTMP+1
       LDX XTMP
       BRA BLKF2
BLKF1  STAA CDR,X
STAB   CDR+1,X
       LDX CDR,X
BLKF2  SUBB #4
       BCC BLKF1
LDAB   FREPTR+1                 * FILL IN LAST CELL
STAB   CDR+1,X
LDAB   FREPTR
STAB   CDR,X
LDAB   XTMP+1                   * UPDATE FREPTR
STAB   FREPTR+1
       STAA FREPTR
       RTS
*
GETCEL LDX FREPTR               * ANY CELLS ON FREE LIST?
       BNE OLDGET
       LDAA ENDPTR+1            * NOPE, ALLOCATE OFF ENDPTR
       BNE GCL2
* ABOUT TO BREAK INTO NEW 256-BYTE PAGE
       JSR GCOL
       LDAA GCFREE+1            * A LOT OF CELLS FREED?
CMPA   #MINFRE
BHS    GETCEL                   * YEP, LOOP AROUND
       LDAA GCFREE
       BNE GETCEL               * (YEP, MORE THAN 256)
       LDAA ENDPTR
       DECA
CMPA   SPCPTR                   * ABOUT TO RUN OUT OF SPACE?
       BLS NOGCEL
       STAA ENDPTR              * NOPE, ALLOCATE NEW DTPR OFF ENDPTR
       LDAA ENDPTR+1
GCL2   SUBA #4
       STAA ENDPTR+1
       LDX ENDPTR               * POINT TO NEW CELL
       STX CELPTR
       BRA NEWGET               * REJOIN COMMON CODE
*
OLDGET STX CELPTR               * PULL CELL OFF FREE LIST
       LDX CDR,X
       STX FREPTR
       LDX CELPTR               * ZERO OUT NEW CELL
NEWGET CLR 0,X
       CLR 1,X
       CLR 2,X
       CLR 3,X
       RTS
NOGCEL LDX #NOGCMG
       JMP ERREX
* PUSH X-REG, WITH LOW BIT SET IN DTPR TO SPECIFY GCOL TRACING
PROPSH INC STKPTR+1
* STACK X-REG ON STKPTR, AND SET CC'S FOR X-REG
PUSHX  STX XTMP                 * SAVE X TEMPORARILY
       BSR GETCEL               * GET A CELL FOR THE ADDITION TO STACK
       LDAA XTMP                * SAVE X-REG IN CAR
       STAA CAR,X
       LDAA XTMP+1
       STAA CAR+1,X
       LDAA STKPTR              * SAVE NEXT CELL IN CDR
       STAA CDR,X
       LDAA STKPTR+1
       STAA CDR+1,X
       STX STKPTR               * UPDATE STKPTR
       LDX XTMP                 * RESTORE X-REG AND SET CC'S
       RTS
* PULL X-REG OFF STKPTR LIST
* ERROR IF STKPTR = 0
POPX   LDX STKPTR
       BEQ POPXER               * OOPS!
       LDAA CDR,X               * UPDATE STKPTR
       STAA STKPTR
       LDAA CDR+1,X
ANDA   #$FE                     * ENSURE THE LOW BIT IS CLEAR
       STAA STKPTR+1
       BSR FRECEL
       LDX CAR,X                * ASSUME FRECEL DOESN'T TOUCH CAR
       RTS
*
POPXER LDX #EOSTKM              * STACK UNDERFLOW!
       JMP ERREX
*
PROPOP EQU POPX                 * FOR SAFETY'S SAKE, POPX ALWAYS CLEARS LOW BIT ANYWAY
* RETURN X-REG STORED AT TOP OF STKPTR STACK
TOPX   LDX STKPTR
       BEQ POPXER
       LDX CAR,X
       RTS
* CHECK THAT FORM CAN BE USED AS TARGET FOR "SET" OR AS A FORMAL ARGUMENT
* RETURN WITH C-BIT CLEAR IF FORM IS LEGAL VAR
ISVAR  JSR ISATOM               * FIRST, IT MUST BE A SYMBOLIC ATOM
       BCS ISVNO
       BLE ISVNO                * (NIL OR NUMBER)
       CPX TATOM                * SECOND, IT MUST NOT BE CERTAIN SPECIAL ATOMS
       BEQ ISVNO
       CLC
       RTS
ISVNO  SEC
       RTS
* TAKES ADDR OF CELL IN X-REG
* ADDS TO FREPTR LIST
* X-REG, AND CAR,X NOT DISTURBED
FRECEL LDAA FREPTR              * SET NEW CDR
       STAA CDR,X
       LDAA FREPTR+1
       STAA CDR+1,X
       STX FREPTR               * UPDATE FREPTR
       RTS
*
GCOL   BSR GCTRCE               * TRACE ALL CELLS
       LDX ZERO                 * INITIALIZE THE FREE LIST
       STX FREPTR
       STX GCFREE               * WILL BE COUNT OF CELLS
       STS GCTEMP               * SAVE STACK POINTER FOR STACK PAGE CHECK
       CLR GCTEMP+1
       LDX ENDPTR               * NOW SCAN THE CELLS
GCF1   CPX GCTEMP               * IS THIS A STACK PAGE?
       BNE GCF3
       LDAA 254,X               * YEP, SET UP POINTER TO NEXT PAGE
       INC GCTEMP               * SKIP UP TO NEXT DTPR
       LDX GCTEMP
       STAA GCTEMP
       BRA GCF1
*
GCF3   CPX ENDMEM               * REACHED END OF MEM?
       BEQ GCFDUN
       LDAA CDR+1,X             * IS THIS CELL MARKED?
BITA   #MRKBIT
       BNE GCFCLR
       BSR FRECEL               * NO, FREE UP CELL
       INC GCFREE+1             * INCREMENT FREE CELL COUNTER
       BNE GCFINX
       INC GCFREE
       BRA GCFINX               * AND ADVANCE TO NEXT CELL
*
GCFCLR EORA #MRKBIT             * CLEAR MARK BIT
       STAA CDR+1,X
       LDAA CAR+1,X
EORA   #MRKBIT
       STAA CAR+1,X
GCFINX INX
       INX
       INX
       INX
       BRA GCF1                 * LOOP TO CHECK NEXT CELL
*
GCFDUN RTS
* TRACE ALL CELLS OF INTEREST:
* FIRST THE X-REG STACK (INCLUDING XTMP IF STKPTR ODD)
* THEN THE SYMBOL LIST
* THEN THE CUREVL LIST AND FORM
* PRESERVES XTMP, FORM, CLOBBERS XTMP2, SONPTR, DADPTR, GCTEMP
GCTRCE LDX ZERO                 * INITIALIZE DADPTR
       STX DADPTR
       LDX XTMP                 * COPY XTMP TO GCTEMP
       STX GCTEMP
       LDAA STKPTR+1            * TRACE XTMP?
       RORA
       LDX STKPTR               * SET UP XTMP2
       BCC GCT2
*
GCT1   STX XTMP2
       LDX GCTEMP
       BSR GCTOBJ               * YEP...
       DEC XTMP2+1              * CLEAR LOW BIT
       LDX XTMP2                * POINT TO NEXT CELL
*
GCT2   BEQ GCT4                 * (ALL DONE)
GCT3   BSR GCTMRK               * MARK THIS CELL, SET UP GCTEMP
       BHI GCT3                 * (-BCC+BNE -- NO NEED TO MARK THIS CELL)
       BCS GCT1                 * AND LOOP
* TRACE THE SYMBOL LIST
GCT4   LDX SYMLST
       BSR GCTOBJ
* NOW TRACE CUREVL AND FORM (NOTE!! FORM MUST ALWAYS BE A FORM!!)
       LDX CUREVL
       BSR GCTOBJ
       LDX FORM
       BSR GCTOBJ
       RTS                      * ALL DONE
* MARK THIS CELL AND STORE CAR IN GCTEMP, CDR IN X-REG
* RETURN WITH C-BIT SET BY LOW BIT OF CDR
* Z&N-BIT SET BY VALUE OF CDR
GCTMRK LDAA CAR,X
       STAA GCTEMP
       LDAA CAR+1,X
       STAA GCTEMP+1
EORA   #MRKBIT                  * USE EOR BECAUSE MAY NOT BE FORM
       STAA CAR+1,X
       LDAA CDR+1,X
ORAA   #MRKBIT
       STAA CDR+1,X
       RORA                     * SET C-BIT
       LDX CDR,X                * SET UP X-REG, Z & N-BIT
       DEX
       DEX
       RTS
* AND NOW THE FUN!!
* SONPTR AND DADPTR POINT TO CURRENT CELL AND ITS FATHER
* SET GC BIT IN CAR, THEN TRACE THE CAR.
* SET GC BIT IN CDR, AND TRACE IT.
* POINTERS ARE REVERSED SO THAT DADPTR MAY BE SET ON THE WAY BACK
* CLOBBERS ONLY A,B,X-REGS, DADPTR AND SONPTR
GCTOBJ STX SONPTR               * SET UP SONPTR, AND COND. CODES
       BGT GCOGO                * AND ENTER TRACE LOOP
GCTRET RTS                      * (NIL OR NUM)
* DONE WITH ATOM, CARRY BIT IS ASSUMED ON(1)
GCODAT DEX                      * ADJUST TO POINT TO START OF CELL
       LDAA CDR+1,X             * LOAD UP ACC
* AND DROP INTO GCOCDD ...
GCOCDD EORA #MRKBIT             * CLEAR MARK BIT IN BACK POINTER
       STAA DADPTR+1
       LDAA CDR,X
       STAA DADPTR
       LDAA SONPTR              * RESET CDR
       STAA CDR,X
       LDAA SONPTR+1
       STX SONPTR               * SET UP NEW SONPTR
       BCC GCOCD2               * WAS IT AN ATOM?
       INC SONPTR+1             * YEP, SET LOW BIT
*
GCOCD2 ORAA #MRKBIT             * SET CDR MARK
       STAA CDR+1,X
* ON THE WAY BACK UP, CHECK IF CDR ALREADY TRACE
GCODUN LDX DADPTR
       BEQ GCTRET               * (ALL DONE)
LDAB   DADPTR+1                 * TRACING AN ATOM?
       RORB
       BCS GCODAT               * YEP, CLEARLY MUST BE DONE WITH IT
       LDAA CDR+1,X             * CDR MARKED?
BITA   #MRKBIT
       BNE GCOCDD
LDAB   CAR+1,X                  * NOPE, TRACE DOWN CDR
STAB   CDR+1,X                  * MOVE BACK POINTER
LDAB   SONPTR+1
ORAB   #MRKBIT
STAB   CAR+1,X                  * RESET CAR WITH MARK BIT ON
       STAA SONPTR+1            * SET NEW SONPTR
       LDAA CDR,X               * NOW THE SAME THING WITH THE HIGH BYTES
LDAB   CAR,X
STAB   CDR,X
LDAB   SONPTR
STAB   CAR,X
       STAA SONPTR
* NOW START WITH A NEW FORM
GCOCA2 LDX SONPTR
       BLE GCODUN               * (NUM OR NIL)
GCOGO  LDAA SONPTR+1            * ATOM?
       RORA
       BCS GCOATM               * (YEP)
LDAB   CAR+1,X                  * IS DTPR ALREADY MARKED?
BITB   #MRKBIT
       BNE GCODUN
       LDAA CAR,X               * NOPE, NIL OR NUM?
       BLE GCOCAA
STAB   SONPTR+1                 * NOPE, TRACE DOWN CAR
       STAA SONPTR
       LDAA DADPTR
       STAA CAR,X
       LDAA DADPTR+1
ORAA   #MRKBIT
       STAA CAR+1,X
       BRA GCOCA4               * JOIN COMMON CODE
* CAR IS NIL OR NUM, TRACE DOWN CDR
GCOCAA LDAA CDR+1,X
       BRA GCOCA3               * (JUST LIKE AN ATOM CELL)
* FORM IS ATOM
GCOATM LDAA CDR+1-1,X           * ATOM ALREADY MARKED?
BITA   #MRKBIT
       BNE GCODUN
       DEX                      * NOPE, POINT TO START OF CELL
LDAB   CAR+1,X                  * COMPLEMENT GC BIT OF CAR
* AT THIS POINT C-BIT SET IF WE HAVE AN ATOM...
GCOCA3 EORB #MRKBIT
STAB   CAR+1,X
LDAB   CDR,X                    * VALUE=NIL OR NUM?
       BLE GCOCD2               * YEP, MARK CDR AND PROCEED
       STAA SONPTR+1            * NOPE, TRACE VALUE OF ATOM
STAB   SONPTR
       LDAA DADPTR
       STAA CDR,X
       LDAA DADPTR+1
ORAA   #MRKBIT
       STAA CDR+1,X
       BCC GCOCA4               * DO WE HAVE AN ATOM?
       INX                      * YEP, SET LOW BIT AGAIN
*
GCOCA4 STX DADPTR               * SET NEW DADPTR
       BRA GCOCA2               * JOIN COMMON CODE
*
EOSTKM FCC 'STACK UNDERFLOW'
       FCB 4
NOGCMG FCC 'NO MORE FREE SPACE'
       FCB 4
STKEMG FCC 'NO ROOM FOR STACK'
       FCB 4
*
BEGADR EQU *
       END
