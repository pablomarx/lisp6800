       NAM LISP-SUBRS2
       OPT PAG
       PAG
OBEGAD EQU $0E90
CAR    EQU 0
CDR    EQU 2
EOI    EQU 4
*
       LIB LISPLB6
* GLOBAL VECTORS
       ORG $0100
EVAL   RMB 3
READ   RMB 3
PRINT  RMB 3
       RMB 3
GETCEL RMB 3
FRECEL RMB 3
PUSHX  RMB 3
POPX   RMB 3
TOPX   RMB 3
EVLATM RMB 3
SETATM RMB 3
LOOKUP RMB 3
GNXTL  RMB 3
GFNXTL RMB 3
LSTINI RMB 3
LSTADD RMB 3
LSTAD2 RMB 3
LSTEND RMB 3
LSTEN0 EQU POPX
ERREX  RMB 3
ATMINI RMB 3
ISDTPR RMB 3
ISATOM RMB 3
GETC   JMP GTCTTY
NUMINV RMB 3
NUMFRM RMB 3
FRMNUM RMB 3
PUTSYM RMB 3
PUTC   JMP PTCTTY
ERRBRK RMB 3
GETSYM RMB 3
STKFRG RMB 3
GCOL   RMB 3
PROPSH RMB 3
GETCAR RMB 3
ISVAR  RMB 3
PRINR  RMB 3
PROPOP RMB 3
*
       ORG OBEGAD
*
MAGWRD EQU $2100        * ('!')
*
DOSPCH EQU $AC18        * DOS PREV CHAR
DOSEOC EQU $AC02        * DOS END OF COMMAND CHAR.
DOSBPT EQU $AC14        * DOS LINE BUFFER POINTER
INBUFF EQU $AD1B        * DOS, READ NEXT LINE
NXTCH  EQU $AD27        * DOS, GET NEXT CHAR FROM BUF
DOSFMS EQU $B406
DOSFCB EQU $A840
DOSTEX EQU $AD33
DOSRPT EQU $AD3F        * DOS, REPORT ERROR
DOSCWD EQU $AC0C        * DOS, CURRENT WORKING DRIVE#
PCRLF  EQU $AD24        * PRINT <CR>,<LF>
PTCTTY EQU $AD18        * PUT A CHAR
* RETURNS NEXT CHAR IN A-REG
* USES SYSTEM INPUT BUFFER
* FORCES SYSTEM TO IGNORE E.O.COMMAND CHAR
GTCTTY LDAA DOSPCH      * GET PREV CHAR?
CMPA   DOSEOC           * IS IT E.O.COMMAND?
       BNE GETC2
       INC DOSBPT+1     * YES, INCREMENT POINTER PAST IT
       BNE GETC3
       INC DOSBPT
*
GETC3  JMP NXTCH        * GET NEXT CHAR AND RETURN
*
GETC2  CMPA #$D         * WAS LAST CHAR <CR>?
       BNE GETC3
       JSR INBUFF       * YEP, REQUEST A NEW BUFFER FULL
       JSR PCRLF        * ECHO <CR,LF>
       CLR DOSPCH       * RETURN <LF>
       LDAA #$A
       RTS
* (LOAD 'PROG.TXT)
* OPENS FILE, CHANGES GETC TO READ DISK FOR CHARS,
* LOOPS READ AND EVAL UNTIL READ RETURNS EOIATM.
* RETURNS NIL
LODFUN FDB MAGWRD
       LDX #DOSFCB      * SET UP FLP FOR OPENFL/OPNTTY
       STX FLP
       BSR GNXTA        * PICK UP ARG
       JSR OPENFL       * GO OPEN FILE
       BCS LODRT        * OPEN FAILED, SIMPLY RETURN NIL
*
LODLUP JSR READ         * READ NEXT FORM
       CPX EOIATM       * EOI?
       BEQ LODRT1       * YEP, ALL DONE
       JSR EVAL         * NOPE, EVAL IT
       BRA LODLUP       * AND LOOP AROUND
*
LODRT1 JSR CLSFN1       * RESET GETC
LODRT  LDX ZERO         * RETURN NIL
       RTS
*
GNXTA  LDX ALP
       JSR GNXTL
       STX ALP
       LDX XTMP
       RTS
* (OPEN 'FILE.TXT)
* OPENS FILE, SUBSEQUENT READS WILL
* READ FROM FILE
* RETURNS ATOM IF SUCCEEDS
* RETURNS NIL IF OPEN FAILS
OPNFUN FDB MAGWRD
       LDX #DOSFCB      * SET UP FLP FOR READ
*
OPNF2  STX FLP
       BSR GNXTA
       STX FORM         * RETURN WITH ATOM
       BSR OPENFL
       BCS OPNFER
       LDX FORM
       RTS
*
OPNFER LDX ZERO         * RETURN WITH NIL
       RTS
* (OPENO 'OFILE.TXT)
* OPENS FILE FOR OUTPUT, RETURNS NIL IF OPEN FAILS
OPOFUN FDB MAGWRD
       LDX #OUTFCB
       BRA OPNF2
* (CLOSEO)
* CLOSES FILE WHICH WAS OPEN FOR OUTPUT
CLOFUN FDB MAGWRD
* CLOSES FILE, SUBSEQUENT READS WILL COME FROM
* TTY
CLOFN1 LDX #OUTFCB
       BRA CLSF2
*
CLSFUN FDB MAGWRD
*
CLSFN1 LDX #DOSFCB
*
CLSF2  STX FLP
       LDAA #4
       STAA 0,X
       JSR DOSFMS
       JSR OPNTTY       * RESET GETC/PUTC
       BRA OPNFER       * AND RETURN WITH NIL
*
OPNERR LDX #OPNEMS      * 'BAD ARG TO OPEN/LOAD'
       JSR ERRBRK       * PICK UP REPLACEMENT ATOM
* EXPECTS ATOM IN X-REG, USES PRINT NAME OF ATOM
* FOR FILENAME (THROWS AWAY ALL '"'S)
OPENFL JSR ISATOM
       BCS OPNERR
       BLT OPNERR
* NIL MEANS SWITCH BACK TO TTY INPUT
* T MEANS SWITCH BACK TO DISK INPUT (MUST ALREADY
* BE OPENED)
* OTHERWISE, USE PRINT NAME AS FILENAME
       BEQ OPNTTY
       CPX EOIATM       * EOIATM?
       BEQ OPNTTY       * YEP, SWITCH BACK TO TTY (E.G. ON RESET)
       CPX TATOM        * T?
       BEQ OPNDSK       * SWITCH BACK TO DISK
* MOVE CHARS INTO FCB
* BY PUSHING ONTO STACK, AND THEN POPPING
* OFF INTO NAME AREA
LDAB   #3               * LIMIT ON EXTENSION
STAB   XTMP             * STORE FOR LATER
LDAB   #8               * LIMIT ON FILE NAME
       DEX              * POINT TO PRINT NAME
       LDX CAR,X
*
OPNLP1 LDAA 0,X         * GET NEXT CHAR
       BEQ OPNL1E       * DONE WITH FIRST LOOP
       INX              * ADVANCE POINTER
CMPA   #'"              * QUOTE?
       BEQ OPNLP1       * YEP, LOOK AT NEXT CHAR
CMPA   #'.              * DOT?
       BEQ OPNL1E       * YEP, ALL DONE
       TSTB             * MORE CHARS TO GO?
       BEQ OPNLP1       * NOPE, LOOP AROUND
       PSHA             * CHAR OK, PUSH IT ON STACK
       DECB             * DECREMENT COUNTER
       BRA OPNLP1       * AND LOOP AROUND
*
OPNL1E CLRA             * CLEAR A FOR PADDING
       TSTB             * NEED TO PAD?
       BEQ OPNL1R       * NOPE, RETURN
*
OPNL2E PSHA             * YEP, PAD WITH ZEROS
       DECB
       BNE OPNL2E
*
OPNL1R LDAB XTMP        * MORE TO DO?
       BEQ OPNL2R       * NOPE
       CLR XTMP         * YEP, CLEAR XTMP AND LOOP AROUND
       BRA OPNLP1
* NOW POP OFF INTO FCB
OPNL2R LDX FLP          * POINT TO FCB
LDAB   #11              * CHAR COUNTER
*
OPNLP2 PULA             * PULL OFF CHAR
       STAA 14,X        * STORE IT
       DEX              * DECR POINTER
       DECB             * DECR COUNTER
       BNE OPNLP2       * AND LOOP UNTIL DONE
*
       LDX FLP          * FILL IN EXTENSION IF NOT PRESENT
       LDAA DOSCWD      * (BUT FIRST, FILL IN DRIVE NUM)
       STAA 3,X
       LDAA #1          * (.TXT)
       JSR DOSTEX
       LDX FLP          * OPEN FOR READING
       LDAA #1
       CPX #OUTFCB      * (OR WRITING?)
       BNE OPNRED
       INCA
*
OPNRED STAA 0,X
       JSR DOSFMS
       BNE OPNOER       * OPEN ERROR
* FLAG GETC TO READ FROM DISK
* OR PUTC TO WRITE TO DISK
OPNDSK LDX FLP
       CPX #OUTFCB
       BEQ OPODSK
       LDX #GTCDSK
       STX GETC+1
*
OPNRET CLC              * AND RETURN
       RTS
*
OPODSK LDX #PTCDSK
       STX PUTC+1
       BRA OPNRET
* RESET GETC TO READ FROM TTY
* OR PUTC TO WRITE TO TTY
OPNTTY LDX FLP
       CPX #OUTFCB
       BEQ OPOTTY
       LDX #GTCTTY
       STX GETC+1
       BRA OPNERT       * RETURN WITH C-BIT
*
OPOTTY LDX #PTCTTY
       STX PUTC+1
       BRA OPNERT
*
OPNOER JSR DOSRPT       * REPORT ERROR
*
OPNERT SEC              * RETURN WITH C-BIT SET
       RTS
*
RATFUN FDB MAGWRD
       JMP GETSYM       * PASS THE BUCK TO GETSYM
*
GNMFUN FDB MAGWRD
* (GENNAME) RETURNS UNIQUE ATOM OF FORM 'IMPABC' (??)
GNM1   LDX SPCPTR       * SAVE POINTER TO BEGINNING OF NEW NAME
       STX SYMPTR
       LDX GNMLAS       * GET LAST ATOM NAME USED
       BNE GNM2
       LDX #GNMFIR      * NEVER INITIALIZED, USE FIRST
       BRA GNM3
*
GNM2   DEX              * POINT TO CELL
       LDX CAR,X        * POINT TO NAME
* COPY TO NAME SPACE
GNM3   LDAA 0,X
       STX XTMP
       LDX SPCPTR
       CPX ENDPTR
       BPL GNMBAD
       STAA 0,X
       INX
       STX SPCPTR
       TSTA             * ALL DONE?
       BEQ GNM4
       LDX XTMP
       INX
       BRA GNM3         * NOPE, LOOP UNTIL NULL BYTE
*
GNM4   LDX SYMPTR       * POINT TO FIRST VARIABLE CHAR
       INX
       INX
       INX
*
GNM41  LDAA 0,X
       BNE GNM42
* UP TO NULL BYTE, SET TO 'A'
       LDAA #'A
       STAA 0,X
       INX
       CPX ENDPTR
       BPL GNMBAD
       CLR 0,X
       INX
       STX SPCPTR
       BRA GNM51        * GO CHECK IF REALLY NEW
*
GNM42  INCA
CMPA   #'Z              * UP TO Z?
       BLS GNM5
       LDAA #'A         * YEP, RESET TO AA
       STAA 0,X
       INX              * GO ON TO NEXT BYTE
       BRA GNM41
*
GNM5   STAA 0,X         * ALL DONE
*
GNM51  LDX SYMPTR
       JSR LOOKUP
       STX GNMLAS
       DEX
       LDX CAR,X        * IS THIS REALLY NEW?
       CPX SYMPTR
       BNE GNM1         * NOPE, START OVER
       LDX GNMLAS       * YEP, RETURN WITH NEW ATOM
       RTS
*
GNMBAD LDX #GNMEMS      * 'NO MORE ROOM FOR TEMP NAME'
       JMP ERREX
*
GNMLAS FDB 0
*
GNMFIR FCC 'TMP'
       FCB 0
* RETURN NEXT CHAR FROM DISK
* RETURN 'EOI' ON ANY ERROR
GTCDSK STX XTMP         * SAVE X-REG
       LDX #DOSFCB
       STX FLP          * SAVE FOR OPNTTY, ETC
       TST 0,X          * OPEN FOR READING?
       BNE GTCDE2       * NOPE, ERROR
       LDAA 2,X
CMPA   #1
       BNE GTCDE2       * NOPE, ERROR
       JSR DOSFMS       * YEP, GET NEXT CHAR
       BNE GTCDER       * ERROR ON READ
       BSR CASWIT       * UPPER<-->LOWER CASE
*
GTCDRT LDX XTMP         * RESTORE X-REG AND RETURN
       RTS
*
GTCDER LDX FLP          * CLOSE FILE
       LDAA #4
       STAA 0,X
       JSR DOSFMS
       LDAA #4          * MAXIMUM NUMBER OF 'EOI'S RETURNED
       STAA GTCECT
*
GTCDE2 DEC GTCECT       * TOO MANY 'EOI'S ALREADY RETURNED?
       BGT GTCDE3
       JSR OPNTTY       * YEP, RESET GETC
*
GTCDE3 LDAA #EOI        * RETURN "EOI"
       BRA GTCDRT
* USED TO RECOVER FROM END OF FILE ERROR
GTCECT FCB 0
* SWITCH UPPER AND LOWER CASE ***HACK***
CASWIT RTS
***
       ORG $1071
* PUT CHAR OUT TO DISK
PTCDSK PSHB             * SAVE B, X-REG
       STX XTMP
       LDX #OUTFCB
       STX FLP          * SET UP FLP FOR OPNTTY, ETC
       TST 0,X          * OPEN FOR WRITING?
       BNE PTCDE2
LDAB   2,X
CMPB   #2
       BNE PTCDE2
       BSR CASWIT       * UPPER<-->LOWER CASE
       JSR DOSFMS       * OUT GOES THE BYTE
       BNE PTCDER       * OOPS!
*
PTCDRT LDX XTMP         * RESTORE X,B-REG
       PULB
       RTS
*
PTCDER JSR DOSRPT       * REPORT ERROR
*
PTCDE2 JSR CLOFN1       * CLOSE FILE
       BRA PTCDRT       * AND RETURN
       LIB SUBLS2
BEGADR EQU *
       END
