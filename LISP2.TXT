       NAM LISP-PRINT
       OPT PAG
       PAG
OBEGAD EQU $05A0
CAR    EQU 0
CDR    EQU 2
EOI    EQU 4
*
       LIB LISPLB
* GLOBAL VECTORS
       ORG $0100
EVAL   RMB 3
READ   RMB 3
       JMP PRINT
       JMP UNDEF
GETCEL RMB 3
FRECEL RMB 3
PUSHX  RMB 3
POPX   RMB 3
TOPX   RMB 3
EVLATM RMB 3
SETATM RMB 3
LOOKUP RMB 3
GNXTL  RMB 3
GFNXTL RMB 3
LSTINI RMB 3
LSTADD RMB 3
LSTAD2 RMB 3
LSTEND RMB 3
LSTEN0 EQU POPX
ERREX  RMB 3
ATMINI RMB 3
ISDTPR RMB 3
ISATOM RMB 3
GETC   RMB 3
NUMINV RMB 3
       JMP NUMFRM
       JMP FRMNUM
       JMP PUTSYM
PUTC   RMB 3
ERRBRK RMB 3
GETSYM RMB 3
STKFRG RMB 3
GCOL   RMB 3
PROPSH RMB 3
GETCAR RMB 3
ISVAR  RMB 3
       JMP PRINR0
PROPOP RMB 3
*
PSTRNG EQU $AD1E
PCRLF  EQU $AD24
* PUTSYM EXPECTS ATOM PTR IN X-REG
* USES PUTC TO OUTPUT CHARS
       ORG OBEGAD
PUTSYM STX FORM
       BMI PUTNUM       * NUMBER--> PUTNUM
       BNE PSY2
       LDX NILATM
PSY2   DEX              * CONVERT ATOM TO POINTER
       LDX CAR,X
       BSR PUTSTR       * OUTPUT THE NAME
       LDX FORM
       RTS
* PUTSTR EXPECTS ADDR OF ZERO-TERMINATED CHAR STRING
* IN X-REG (WHICH IS CLOBBERED!)
* USES PUTC TO OUTPUT INDIVIDUAL CHARS.
PUTSTR EQU *
*
PSNXT  LDAA 0,X
       BEQ PSRT
       JSR PUTC
       INX
       BRA PSNXT
PSRT   RTS
* PUTNUM EXPECTS FORM IN X-REG
* USES PUTC TO OUTPUT IT
PUTNUM BSR FRMNUM       * CONVERT FORM TO NUMBER
       BPL PNM2
       LDAA #'-         * NUMBER IS NEGATIVE
       JSR PUTC
       JSR NUMINV       * CONVERT TO ITS ABSOLUTE VALUE
PNM2   STX XTMP         * LOAD NUM INTO A AND B REGS
       LDAB XTMP
       LDAA XTMP+1
       LDX FORM         * RESTORE X-REG FOR RETURN
PNUMR  TSTB             * ANY HIGHER ORDER DIGITS?
       BNE PNMR2
       CMPA #$09
       BLS PNMR3
*
PNMR2  PSHA             * YEP, SAVE A
       LSRB             * SHIFT RIGHT
       RORA
       LSRB
       RORA
       LSRB
       RORA
       LSRB
       RORA
       BSR PNUMR        * RECURSE TO PRINT OTHER DIGITS
       PULA             * RESTORE A
       ANDA #$0F        * AND OUT HIGHER DIGITS
*
PNMR3  ORAA #'0         * FORM ASCII CODE
       JMP PUTC         * PUT DIGIT AND RETURN
* EXPECTS FORM IN X-REG
* RETURNS 4-DIGIT BCD NUMBER IN X-REG
* USING 10'S COMPLEMENT
* N-BIT SET IF NUMBER IS NEGATIVE
* Z-BIT SET IF NUM IS ZERO
FRMNUM STX FORM         * STORE THE FORM
       LDAA ENDMEM      * SET UP HIGH BYTE OF FRMNUM TABLE ADDRESS
       STAA XTMP
       LDAA FORM+1      * CONVERT LOW BYTE
       TAB
       SEC
       RORA
       LSRA
       BSR FNX
       RORB             * SET UP LOW BIT
       ROLA
       STAA XTMP2+1     * AND STORE RESULT
       LDAA FORM        * CONVERT HIGH BYTE
       LSRA
       BSR FNX
       ROLA             * SET LOW BIT
       STAA XTMP2
       LDX XTMP2        * LOAD RESULT
       BEQ FNMRET       * SET UP Z AND N BIT
       ADDA #$30
       TSTA
FNMRET RTS
* EXPECTS BCD NUMBER IN X-REG (10'S COMPLEMENT)
* CONVERTS TO FORM, WITH HIGH BIT SET, AND BIT 1=0 FOR GCOL
NUMFRM STX XTMP2        * STORE THE NUMBER
       LDAA ENDMEM      * SET UP HIGH BYTE OF NUMFRM TABLE ADDR
       STAA XTMP
       LDAA XTMP2+1     * CONVERT LOW BYTE
       TAB
       BSR NFX
       ASLA
       RORB             * SET UP LOW BIT
       ROLA
       STAA FORM+1      * STORE THE RESULT
       LDAA XTMP2       * CONVERT THE HIGH BYTE
       BSR NFX
       ROLA             * SET UP THE LOW BIT
       STAA FORM
       LDX FORM         * RETURN THE RESULT
       RTS
*
NFX    SEC
       RORA             * LOW BIT==> C-BIT, 1==> HIGH BIT
FNX    STAA XTMP+1      * STORE LOW BYTE OF FRMNUM/NUMFRM TABLE ADDR
       LDX XTMP
       LDAA 0,X         * LOAD CONVERTED VALUE
       RTS              * AND RETURN
* "PRINT" TYPES OUT FORM, FOLLOWED BY CR,LF
* USES RECURSIVE ROUTINE "PRINR" TO DO THE WORK
* FORM RETURNED IN X-REG AND "FORM"
PRINT  LDAA RSTFLG      * IN A RESET?
       BEQ PRINT1
PRINRT RTS              * YEP, RETURN IMMEDIATELY
PRINT1 BSR PRINR        * CALL RECURSIVE PRINT ROUTINE
       STX FORM         * SAVE IN FORM
       LDAA #$D         * CR,LF
       BSR PPUTC
       LDAA #$A
       BRA PPUTC
* TYPE OUT FORM, WITHOUT CR,LF
PRINR0 LDAA RSTFLG      * IN A RESET?
       BNE PRINRT       * YEP, SIMPLY RETURN
* PRINT TAKES ADDR OF OBJECT IN X-REG
* ASSUMES EITHER DTPR, NIL, ATOM, OR NUMBER
* CALLS PUTSYM AND PUTC
* ASSUMES "NIL" ATOM STORED AT "NILATM"
* USES PUSHX SUBR TO STACK X-REG
* ALSO POPX AND TOPX TO REFERENCE STACK
PRINR  JSR ISATOM       * SWITCH ON TYPE OF FORM
       BCS DTPRT
       JMP PUTSYM       * NIL, ATOM, OR NUMBER
*
DTPRT  JSR PROPSH       * SAVE X-REG FOR RESTORE LATER
       JSR STKFRG       * FRAGMENT THE STACK
* GOT A DTPR, PRINT "("
       LDAA #'(
       BSR PPUTC
       LDX CAR,X        * PRINT THE CAR
       BSR PRINR        * RECURSIVELY!
       JSR TOPX         * RESTORE X-REG
PRT2   LDX CDR,X        * AND FOLLOW LIST
       JSR ISDTPR       * CHECK TYPE OF FORM
       BEQ PRT4         * NIL ==> END OF LIST
       BCS PRT35        * A NUMBER OR AN ATOM(?!)
PRT3   BSR PPUTSP       * PRINT A SPACE
       JSR PUSHX        * SAVE X-REG
       LDX CAR,X        * PRINT THE CAR
       BSR PRINR        * RECURSIVELY!
       JSR POPX         * RESTORE X-REG
       BRA PRT2
* ATOM OR NUMBER AT END OF LIST
* USE "." SYNTAX
PRT35  BSR PPUTSP       * PUT OUT " . "
       LDAA #'.
       BSR PPUTC
       BSR PPUTSP
       BSR PRINR        * RECURSE TO PRINT OBJECT
*
PRT4   LDAA #')         * END THE LIST
       BSR PPUTC
       JMP PROPOP       * RESTORE X-REG AND RETURN
PPUTSP LDAA #$20
PPUTC  JMP PUTC         * USED TO AVOID LONG JSR
*
UNDEF  SWI              * STOP, CALLED TYPSWI FROM SOMEWHERE
       BRA UNDEF
BEGADR EQU *
       END
