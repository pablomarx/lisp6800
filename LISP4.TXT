       NAM LISP-EVALSUBS
       OPT PAG
       PAG
OBEGAD EQU $0940
CAR    EQU 0
CDR    EQU 2
EOI    EQU 4
*
       LIB LISPLB4
* GLOBAL VECTORS
       ORG $0100
       JMP EVAL
READ   RMB 3
PRINT  RMB 3
       RMB 3
GETCEL RMB 3
FRECEL RMB 3
PUSHX  RMB 3
POPX   RMB 3
TOPX   RMB 3
       JMP EVLATM
       JMP SETATM
LOOKUP RMB 3
       JMP GNXTL
       JMP GFNXTL
       JMP LSTINI
       JMP LSTADD
       JMP LSTAD2
       JMP LSTEND
*
ERREX  RMB 3
ATMINI RMB 3
       JMP ISDTPR
       JMP ISATOM
GETC   RMB 3
NUMINV RMB 3
NUMFRM RMB 3
FRMNUM RMB 3
PUTSYM RMB 3
PUTC   RMB 3
ERRBRK RMB 3
GETSYM RMB 3
STKFRG RMB 3
GCOL   RMB 3
PROPSH RMB 3
GETCAR RMB 3
ISVAR  RMB 3
PRINR  RMB 3
PROPOP RMB 3
*
       ORG OBEGAD
* EVAL EXPECTS FORM PASSED IN X-REG
* RETURNS EVALUATION OF FORM IN X-REG AND "FORM"
EVAL   TST RSTFLG                  * INSIDE A RESET?
       BNE EVLEOI                  * YEP, RETURN EOIATM
       JSR ISATOM
       BCS EVLDTP                  * (DTPR)
       BLE EVLRT                   * (NIL OR NUM)
EVLATM LDX CDR-1,X                 * RETURN CURRENT BINDING
EVLRT  STX FORM
       RTS
EVLEOI LDX EOIATM                  * RETURN EOIATM
       BRA EVLRT
EVLDTP STX FORM                    * SAVE X-REG TEMPORARILY (AND PROTECT IT)
       JSR STKFRG                  * FRAGMENT THE STACK
       LDAA ALP+1                  * SAVE ALP,NLP,FLP ON STACK
       PSHA
       LDAA ALP
       PSHA
       LDAA NLP+1
       PSHA
       LDAA NLP
       PSHA
       LDAA FLP+1
       PSHA
       LDAA FLP
       PSHA
       JSR GETCEL                  * GET A CELL TO ADD TO CUREVL LIST
       LDAA FORM
       STAA CAR,X
       LDAA FORM+1
       STAA CAR+1,X
       LDAA CUREVL
       STAA CDR,X
       LDAA CUREVL+1
       STAA CDR+1,X
       STX CUREVL
       LDX FORM                    * SAVE POINTER TO ARG LIST
       LDX CDR,X
       STX ALP
       LDX FORM                    * POINT BACK TO THIS FORM
       LDX CAR,X                   * POINT TO FUNC. OR EXPLICIT LAMBDA
       BSR EVAL                    * RECURSE TO EVAL IT
       JSR ISDTPR                  * IS RESULT A DTPR?
       BCS EVLERR                  * NOPE
* NOW X-REG SHOULD BE EXPLICIT LAMBA EXPR
       STX FORM                    * SAVE FOR LATER
       LDX CDR,X
       STX FLP                     * (FUNCTION DEF LIST POINTER)
       LDX FORM                    * POINT BACK TO BEG. OF LIST
       LDX CAR,X                   * NOW LOOK FOR LAMBDA,NLAMBDA,SUBR,NSBUR
       CPX SUBRAT
       BEQ EVLSUB
       CPX NSUBAT
       BEQ EVLNSU
       CPX LAMATM
       BEQ EVLLAM
       CPX NLAMAT
       BEQ EVLNLA
*
EVLERR LDX #EVLEMS
       BRA EVLER2
* EVALUATE (NSUBR,FUNCADDR)
EVLNSU LDX ZERO                    * SET UP A NULL LIST ON TOP OF STACK FOR POPFRE
       JSR PROPSH
       BRA EVNSU2
* EVALUATE (SUBR,FUNCADDR)
EVLSUB BSR EVLALS
       LDX EOIATM
       TST RSTFLG                  * IN A RESET?
       BNE EVLSB5                  * YEP, RETURN EOIATM
*
EVNSU2 LDX FLP                     * PICK UP THE ADDR
       JSR ISATOM
       BCS EVLSER                  * GACK!
       BLE EVLSER                  * NIL OR NUMBER JUST AS BAD!
       DEX                         * CONVERT TO CELL POINTER
       LDX CAR,X                   * GET ADDR OF FUNCTION
       LDAA 0,X                    * CHECK MAGIC BYTE
CMPA   #'!
       BNE EVLSER
       TST 1,X
       BNE EVLSER
* ALP NOW HAS ARG LIST
       JSR 2,X                     * CALL THE FUNCTION
EVLSB5 STX FORM                    * SAVE RESULT
       BSR POPFRE                  * FREE THE ARG LIST
       BRA EVLRT5                  * AND CLEAN UP
*
EVLSER BSR POPFRE                  * FREE THE ARG LIST
       LDX #EVLSMS                 * 'BAD SUBR/NSUBR
*
EVLER2 JSR ERRBRK
       BRA EVLRT4
*
EVLALS JSR LSTINI                  * BUILD UP LIST ON STACK OF EVAL B(?) ARGS
EVLSB2 LDX ALP
       JSR GNXTL
       BCS EVLSB3
       STX ALP
       LDX XTMP
       JSR EVAL                    * EVAL NEXT ARG
       JSR LSTADD                  * ADD TO LIST
       BRA EVLSB2                  * AND LOOP
*
EVLSB3 JSR LSTEN0                  * END THE LIST
       JSR TOPX                    * GET LIST AND STORE IN ALP
       STX ALP
       RTS
* EVALUATE (NLAMBDA (L) EXPR)
* SIMULATE EVLALS BY MAKING ONE-ELEMENT LIST
* WITH UNEVAL'D ARGLIST AS SINGLE "ACTUAL" ARG
EVLNLA JSR LSTINI
       LDX ALP
       JSR LSTADD
       JSR LSTEN0
       BRA EVLNL2                  * JOIN COMMON CODE
* EVALUATE (LAMBDA (X Y) EXPR)
EVLLAM BSR EVLALS                  * EVALUATE ACTUAL ARGUMENTS
EVLNL2 BSR EVLNSV                  * SAVE OLD AND SET NEW VALUES OF FORMALS
* TOP OF STACK NOW POINTS TO LIST OF FORMALS
* JUST BELOW IS LIST OF THEIR OLD VALUES
EVLBOD LDX FLP                     * EVAL BODY OF LAMBDA/NLAMBDA
       JSR GETCAR                  * POINT TO BODY OF LAMBDA
       JSR EVAL
       STX FLP                     * SAVE RESULT IN FLP
       BSR EVLRST                  * GO RESTORE OLD VALS OF FORMALS
       LDX FLP                     * TRANSFER FINAL RESULT TO FORM
*
EVLRT4 STX FORM
EVLRT5 LDX CUREVL                  * POP CUREVL LIST
       BSR GFNXTA
       LDX ALP
       STX CUREVL
       PULA                        * RESTORE FLP,NLP,ALP
       STAA FLP
       PULA
       STAA FLP+1
       PULA
       STAA NLP
       PULA
       STAA NLP+1
       PULA
       STAA ALP
       PULA
       STAA ALP+1
       LDX FORM                    * RETURN WITH RESULT IN X-REG
       RTS
* FREE THE ARG LIST (LIST HEAD IS AT TOP OF STACK)
POPFRE JSR PROPOP
       BEQ PFRDUN                  * (ALL DONE)
PFR2   BSR GFNXTA                  * ADVANCE ALP
PFR3   LDX ALP                     * AND LOOP FOR CDR
       BNE PFR2
PFRDUN RTS
*
GFNXTA LDAA CDR,X                  * ADVANCE ALP
       STAA ALP
       LDAA CDR+1,X
       STAA ALP+1
       JMP FRECEL                  * FREE UP THE CELL, AND RETURN
*
EVLRST JSR PROPOP                  * SET UP NLP,ALP FOR RESTORE
       STX NLP
EVLRS0 JSR PROPOP
EVLRS1 STX ALP
       BEQ EVLRS3
EVLRS2 BSR GFNXTA                  * FREE CELL AND ADVANCE ALP
       LDX CAR,X                   * (FRECEL DOESN'T TOUCH CAR)
EVLRS3 STX FORM
       LDX NLP
       JSR GNXTL
       BCS PFR3                    * ALL DONE, FREE UP REST OF ALP LIST
       STX NLP
       LDX XTMP
       JSR SETATM                  * STORE NEW VALUE FOR ATOM
       LDX ALP
       BEQ EVLRS3
       BRA EVLRS2
* COMMON CODE TO SAVE OLD AND SET NEW VALUES OF FORMALS
EVLNSV LDX STKPTR                  * SET UP ALP AS ACTUAL ARG LIST POINTER
       DEX
       DEX
       STX ALP
* SET UP NLP AS FORMAL ARG LIST POINTER
       LDX FLP
       JSR GNXTL
       STX FLP                     * (AND ADVANCE FLP)
       LDX XTMP
       JSR PROPSH                  * SAVE FORMAL ARG LIST POINTER ON STACK
*
EVLNS1 JSR GNXTL                   * GET NEXT FORMAL ARG AND ADVANCE NLP
       BCS EVLNS5                  * (ALL DONE)
       STX NLP
* NEXT FORMAL ARG NOW IN XTMP
* NOW GET PTR TO NEXT ACTUAL ARG
       LDX ALP
       LDX CDR,X                   * ANY MORE ACTUAL ARGS?
       BNE EVLNS2
* NO MORE ACTUAL ARGS, CREATE ONE = NIL AND ADD TO LIST
       JSR GETCEL
       LDX ALP
       LDAA CELPTR
       STAA CDR,X
       LDAA CELPTR+1
       STAA CDR+1,X
       LDX CELPTR
* ADVANCE ALP
EVLNS2 STX ALP
       LDX CAR,X                   * STORE NEXT ACTUAL ARG IN XTMP2
       STX XTMP2
* GET OLD VALUE OF FORMAL ARG, SAVE IN LIST
       LDX XTMP                    * BUT FIRST, IS FORMAL ARG A LEGAL ATOM?
       JSR ISVAR
       BCS EVLNER                  * (NOPE!)
       JSR EVLATM
* OLD VALUE NOW IN FORM, SAVE IN LIST
       LDX ALP
       LDAA FORM
       STAA CAR,X
       LDAA FORM+1
       STAA CAR+1,X
* SET UP NEW VALUE FOR ATOM
       LDX XTMP2
       STX FORM
       LDX XTMP
       JSR SETATM
       LDX NLP                     * MOVE ON TO NEXT FORMAL ARG
       BNE EVLNS1
*
EVLNS5 RTS                         * ALL DONE
* WE GOT A BAD FORMAL ARG, COMPLAIN...
EVLNER STX FORM
       LDX #EVLNMS                 * 'BAD FORMAL ARG'
       JSR ERRBRK
       BRA EVLNS5                  * IGNORE RETURNED VALUE
* RETURN C-BIT SET IF NOT DTPR
* RETURN Z-BIT SET IF IS NIL
* BCC WILL BRANCH ON DTPR
* BEQ WILL BRANCH ON NIL
ISDTPR SEC
       STX XTMP                    * STORE AND SET CC'S
       BLE ISDTRT                  * NIL OR NUMBER==> RETURN WITH Z&C CORRECT
       LDAA XTMP+1                 * CHECK LOW BIT
       RORA                        * SET C-BIT IF NOT DTPR
       LDX XTMP                    * CLEAR Z-BIT
ISDTRT RTS                         * C-BIT NOW SET PROPERLY
* RETURN WITH C-BIT IF NOT ATOM
* RETURN WITH Z-BIT IF NIL
* RETURN WITH N-BIT SET IF NUMBER
* BHI WILL BRANCH ON NON-NIL ATOM
ISATOM CLC                         * SET UP C-BIT FOR ATOM
       STX XTMP                    * STORE AND SET Z&N-BITS
       BLE ISATRT                  * NIL OR NUM, RET WITH Z,N,C CORRECT
       LDAA XTMP+1                 * CHECK LOW BIT
       INCA                        * (COMPLEMENTED --> C-BIT)
       RORA
       LDX XTMP                    * (CLEAR Z-BIT)
ISATRT RTS                         * CC'S NOW SET UP CORRECTLY
* THIS SETS UP THE STACK FOR LSTADD
* FIRST IT STACKS A NIL, THEN A POINTER
* TO THE NIL
* CALL LSTINX IF X-REG POINTS TO LIST HEADER
LSTINI LDX ZERO
       JSR PROPSH
       LDX STKPTR
*
LSTINX DEX
       DEX
       JMP PUSHX                   * PUSH POINTER AND RETURN
* ADD FORM IN X-REG TO LIST POINTER ON STACK
* CALL LSTAD2 IF ALREADY STORED IN 'FORM'
LSTADD STX FORM
LSTAD2 JSR GETCEL                  * GET A NEW CELL
       LDAA FORM                   * FILL IN CAR
       STAA CAR,X
       LDAA FORM+1
       STAA CAR+1,X
       JSR TOPX                    * GET LIST POINTER
       LDAA CELPTR                 * (CELPTR FILLED IN BY GETCEL)
       STAA CDR,X
LDAB   CELPTR+1
STAB   CDR+1,X                     * NOW ADDED TO LIST
       LDX STKPTR                  * UPDATE LIST POINTER
       STAA CAR,X
STAB   CAR+1,X
       RTS
* FILL IN CDR OF LAST CELL IN LIST
* ALSO POP OFF LIST POINTER
* CALL LSTEN2 IF FORM ALREADY STORED IN 'FORM'
LSTEND STX FORM
LSTEN2 JSR POPX                    * POP OFF LIST POINTER
       LDAA FORM
       STAA CDR,X
       LDAA FORM+1
       STAA CDR+1,X
       RTS
*
LSTEN0 EQU POPX                    * USE THIS IF LIST ENDED WITH NIL
* GET NEXT LIST ELEMENT
* X-REG CONTAINS LIST POINTER
* RETURNS CDR IN X-REG, CAR IN XTMP, C-BIT SET IF NOT DTPR
GNXTL  STX XTMP                    * DTPR?
       BLE GNLNO
       LDAA XTMP+1
       RORA
       BCS GNLNO
       LDAA CAR,X                  * YEP, RETURN CAR IN XTMP
       STAA XTMP
       LDAA CAR+1,X
       STAA XTMP+1
       LDX CDR,X
       RTS                         * RETURN WITH C-BIT CLEAR
*
GNLNO  LDX ZERO                    * RETURN NIL IN XTMP
       STX XTMP
       SEC
       RTS                         * RETURN WITH C-BIT SET
* SAME AS GNXTL, EXCEPT ALSO FREES CELL AFTER
* RETURNING ITS CONTENTS
GFNXTL JSR ISDTPR                  * DTPR?
       BCS GNLNO
       LDAA CDR,X                  * YEP, SAVE CDR
       STAA XTMP2
       LDAA CDR+1,X
       STAA XTMP2+1
       JSR FRECEL                  * FREE UP CELL
       LDX CAR,X                   * SET UP XTMP
       STX XTMP
       LDX XTMP2                   * RETURN WITH X-REG ADVANCED
       CLC                         * AND C-BIT CLEAR
       RTS
* EXPECTS ATOM IN X-REG
* NEW BINDING IN FORM
* COMPENSATE FOR CELPTR = ATOM-1
SETATM LDAA FORM
       STAA CDR-1,X
       LDAA FORM+1
       STAA CDR+1-1,X
       RTS
*
EVLSMS FCC 'BAD SUBR/NSUBR'
       FCB 4
EVLNMS FCC 'BAD FORMAL ARG'
       FCB 4
EVLEMS FCC 'ILLEGAL FUNCTION EVAL'
       FCB 4
*
BEGADR EQU *
       END
