 NAM LISP
 OPT NOG,PAG
 PAG
*SIMPLE LISP INTERPRETER
*
OBEGAD EQU $200
CAR EQU 0
CDR EQU 2
EOI EQU 4
 LIB LISPLB
*GLOBAL VECTORS
 ORG $0100
EVAL RMB 3
 JMP READ
PRINT RMB 3
 RMB 3
GETCEL RMB 3
FRECEL RMB 3
PUSHX RMB 3
POPX RMB 3
TOPX RMB 3
EVLATM RMB 3
SETATM RMB 3
LOOKUP RMB 3
GNXTL RMB 3
GFNXTL RMB 3
LSTINI RMB 3
LSTADD RMB 3
LSTAD2 RMB 3
LSTEND RMB 3
LSTEN0 EQU POPX
 JMP ERREX
ATMINI RMB 3
ISDTPR RMB 3
ISATOM RMB 3
GETC RMB 3
NUMINV RMB 3
NUMFRM RMB 3
FRMNUM RMB 3
PUTSYM RMB 3
PUTC RMB 3
 JMP ERRBRK
GETSYM RMB 3
STKFRG RMB 3
GCOL RMB 3
PROPSH RMB 3
 JMP GETCAR
ISVAR RMB 3
PRINR RMB 3
PROPOP RMB 3
*
 ORG OBEGAD
*
START EQU *
 STS SPSAVE
 LDX BEGPTR
 STX SPCPTR
 LDX ENDMEM
 STX ENDPTR
* INITIALIZE TABLES FOR NUMFRM AND FRMNUM
* LAST 128 BYTES OF MEM HOLD TABLE TO CONVERT HIGH 7 BITS OF BCD TO 6 BITS OF BINARY
* PREVIOUS 64 BYTES HOLD TABLE TO CONVERT 6 BITS TO 7 BITS
* BIT 6 OF 128 BYTE TABLE IS ALWAYS ON
 LDAA ENDMEM		* SET UP HIGH BYTE OF XTMP
 STAA XTMP
 LDAA #$40			* INITIALIZE TABLES TO 40'S
 LDAB #192
NUMILP EQU *
 STAA 0,X
 INX
 DECB
 BNE NUMILP
* SET UP 64-BYTE TABLE
 LDX ENDMEM
 CLRA
NUM64I EQU *
 LSRA
 STAA 0,X
 INX
 ASLA
 ADDA #2
 DAA
 BCC NUM64I
* SET UP 128-BYTE TABLE
 LDAA #$80			* START ADDR
 STAA XTMP+1
 LDX XTMP
 LDAA #$40
NM128I EQU *
 LDAB #5			* INNER COUNTER
N128I2 EQU *
 STAA 0,X
 INX
 INCA
 DECB
 BNE N128I2
 INX				* SKIP 3 BYTES
 INX
 INX
 CMPA #50+$40		* ALL DONE?
 BNE NM128I
* YEP, TABLES NOW SET UP
 CLRA
 STAA PEEKC
 LDX ZERO
 STX FREPTR
 STX SYMLST
 STX STKPTR
 STX NILATM
 STX CUREVL
 STX FORM			* FORM MUST ALWAYS BE A LEGALLY TRACEABLE FORM
* INITIALIZE BUILT-IN ATOMS
 JSR ATMINI
*
BIGLUP EQU *
 CLR RSTFLG			* CLEAR RESET FLAG
 LDX #PROMSG		* '->'
 JSR PSTRNG
 JSR READ
 JSR PCRLF
 JSR EVAL
 BSR PPRINT
 BRA BIGLUP
*
ERREX EQU *
 LDS SPSAVE
 JSR PSTRNG
 JSR PCRLF
 SWI				* SOFTWARE INT (EXIT TO SWIBUG)
 JMP START			* RESTART
*
PPRINT JMP PRINT	* SAVE A FEW JSR'S
*
ERRBRK EQU *		* CONTINUABLE ERROR
 INC EFLAG			* INDICATE IN ERROR CODE
 JSR PSTRNG			* PRINT ERROR MESSAGE
 JSR PCRLF
 LDX FORM			* PRINT CURRENT VALUE
 BEQ ERRBR2
 BSR PPRINT
ERRBR2 EQU *
 LDX CUREVL			* PRINT CURRENT FORM BEING EVAL'D
 JSR GETCAR
 BCS ERRBR3
 BSR PPRINT
ERRBR3 LDAA RSTFLG	* RESET OR RETBRK?
 BEQ ERRLUP
ERRSET LDX EOIATM	* YEP, RESULT IS NOTHING
 ADDA #'0			* AT THIS LEVEL?
 CMPA EFLAG
 BLO ERRETN			* NOPE, KEEP RESETTING
 CLR RSTFLG			* YEP, CLEAR RESET FLAG
ERRLUP LDX #EFLAG	* ERROR PROMPT (E.G. "2:> ")
 LDAA 0,X			* FIRST LEVEL?
 CMPA #'1
 BNE ERRLP2
 INX				* YEP, SKIP PAST DIGIT
ERRLP2 JSR PSTRNG
 JSR READ			* READ AND EVAL
 STX FORM
 JSR GETCAR			* BUT FIRST , IS IT (CONT ...)
 CPX CONATM			* `CONT`?
 BEQ ERRCON			* YEP, RETURN WITH ARG TO CONT
 LDX FORM			* NOPE, EVAL FORM
 JSR EVAL
 LDAA RSTFLG		* IN A RESET?
 BNE ERRSET			* YEP, CHECK LEVEL
 BSR PPRINT			* PRINT VALUE
 BRA ERRLUP			* AND LOOP AROUND
*					* CONTINUE
ERRCON LDX FORM		* GET ARG
 LDX CDR,X
 JSR GETCAR
 JSR EVAL			* EVAL ARG TO CONT AND RETURN
ERRETN DEC EFLAG	* BACK UP EFLAG
 STX FORM			* RETURN WITH RESULT IN FORM AND X-REG
 RTS
*
EFLAG FCB '0		* IF NON-ZERO, NOW IN ERROR CODE
 FCC ':> '
 FCB 4
* EXPECTS FORM IN X-REG
* SETS C-BIT IF NOT A LEGAL FORM
ISFORM STX XTMP		* STORE IT AND SET CC'S
 BLE ISFRT			* NIL OR A NUMBER, A-OK
 CPX ENDPTR			* LEGAL CELL ADDR?
 BPL ISFRT			* YEP
 SEC				* NOT LEGAL, SET C-BIT
 RTS
ISFRT CLC			* LEGAL, CLEAR C-BIT
 RTS
* READ ASSEMBLES A FORM, USING GETQSY'S
* TO RETRIEVE THE TOKENS
* FORM RETURNED IN X-REG AND "FORM"
* A AND B-REGS CLOBBERED!
READ CLR RBRKFG		* INITIALIZE RIGHT BRACKET FLAG
READR JSR GETQSY
* (ASSUME RESULT ALSO SAVED IN FORM)
 CPX LPARAT			* IS IT A LEFT PAREN?
 BEQ READL			* YEP, RETURN RESULT FROM READL
 CPX LBRKAT			* LEFT BRACKET ("[")?
 BNE READRT
 BSR READL			* YEP, READ AND CLEAR RBRKFG
 CLR RBRKFG
READRT RTS			* NOPE, SIMPLY RETURN WITH ATOM
*
RBRKFG FCB 0		* POSITIVE WHEN "]" FOUND
*
READL JSR LSTINI	* INITIALIZE RDLST AND RDLPTR
 JSR STKFRG			* ADD A NEW FRAGMENT TO STACK
RDL2 BSR READR		* GET NEXT FORM
 CPX RPARAT			* RIGHT PAREN?
 BEQ RDLRT			* YES, FINISH UP READL
 CPX DOTATM			* "."?
 BEQ RDLDOT			* YES, GO FINISH UP WITH ONE MORE READ
* FORM IS POINTING TO OBJECT TO BE ADDED TO LIST
 CPX EOIATM			* PREMATURE END OF INPUT?
 BEQ RDLEOI			* YEP, TREAT LIKE "]"
 JSR LSTAD2			* ADD TO LIST
 BRA RDL2			* GO GET NEXT FORM
*
RDLEOI INC RBRKFG	* EOIATM ENCOUNTERED, CLOSE OFF UNFINISHED LISTS
RDLRT JSR LSTEN0	* POP OFF RDLPTR
RDLRT2 JSR PROPOP	* POP OFF AND RETURN RDLST
 STX FORM
 RTS
*
RDLDOT BSR READR	* PULL IN NEXT FORM
 JSR LSTEND			* FILL IN CDR OF LAST CELL
 JSR GETQSY			* NOW, REQUIRE ")" TO END IT ALL
 CPX RPARAT
 BEQ RDLRT2			* ALL DONE NOW!
* ERROR IN LIST STRUCTURE...
RLSTER JSR PROPOP	* POP OFF FORM BEING BUILT
 STX FORM
 LDX #RLERMS
 DEC RSTFLG			* FORCE IMMEDIATE RETURN FROM ERRBRK
 JSR ERRBRK
 CLR RSTFLG
 RTS				* AND RETURN WITH RESULT IN X-REG AND FORM
* SAME AS GETSYM, ONLY CHECK FOR "'"
* AND BUILD UP (QUOTE ...) IF FOUND
* ALSO DEAL WITH "]" FEATURE
GETQSY LDAA RBRKFG	* RIGHT BRACKET FLAG SET?
 BNE GQSRPR			* YEP, RETURN A "]"
 JSR GETSYM
 CPX RBRKAT			* RIGHT BRACKET?
 BEQ GQSRBK			* YEP, SET RBRKFG AND RETURN A ")"
 CPX SQUTAT			* "'" ?
 BNE GQSRT
 JSR READ			* YES, PICK UP NEXT FORM
 STX FORM			* SAVE POINTER
 JSR GETCEL			* PICK UP A CELL
 LDAA FORM			* FILL IN THE CAR
 STAA CAR,X
 LDAA FORM+1
 STAA CAR+1,X
 STX FORM			* SAVE IT AGAIN
 JSR GETCEL			* ANOTHER CELL...
 LDAA QUOATM		* WITH "QUOTE" ATOM
 STAA CAR,X
 LDAA QUOATM+1
 STAA CAR+1,X
 LDAA FORM
 STAA CDR,X
 LDAA FORM+1
 STAA CDR+1,X
GQSR0 STX FORM		* RETURN WITH FORM IN FORM
GQSRT RTS
*
GQSRBK INC RBRKFG	* SET RIGHT BRACKET FLAG
GQSRPR LDX RPARAT	* RETURN ")"
 BRA GQSR0
* RETURN CAR OF X-REG OR NIL IF NONE (SETS C-BIT IF NONE)
GETCAR STX XTMP
 BLE GCANIL
 ROR XTMP+1			* ATOM?
 BCS GCANIL
 LDX CAR,X			* NO, RETURN CAR
 RTS				* RETURN WITH C-BIT CLEAR
GCANIL LDX ZERO		* RETURN NIL
 SEC				* AND C-BIT SET
 RTS
*
PSTRNG EQU $AD1E
PCRLF EQU $AD24
* TABLES, ETC.
RLERMS FCC 'READ LIST ERROR'
 FCB 4
PROMSG FCC '-> '
 FCB 4
BEGADR EQU *
 END START

